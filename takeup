#!/usr/bin/env ruby

require 'yaml'

use_color    = true
project_root = Dir.pwd
project_name = File.basename(project_root)
support_root = "#{File.expand_path("~/.takeup")}/#{project_name}"

interpolator = lambda do |*args|
  string = args[0]
  extras = args[1] || {}

  if string
    result = string.dup
    result.gsub!(':project_root', project_root)
    result.gsub!(':project_name', project_name)
    result.gsub!(':support_root', support_root)

    extras.each_pair do |key, value|
      result.gsub!(key, value) if value
    end

    result
  end
end

processes = []

begin
  config = YAML.load(File.read("#{support_root}/manifest.yml"))
rescue Errno::ENOENT
  puts "Manifest for #{project_name} doesn't exist. Please create it at #{support_root}/manifest.yml."
  exit(1)
end

config.each do |process|
  pid_file = interpolator.call(process['pid_file'])

  processes << { 'name'     => process['name'],
                 'pid_file' => pid_file,
                 'start'    => interpolator.call(process['start'], ':pid_file' => pid_file),
                 'stop'     => interpolator.call(process['stop'], ':pid_file' => pid_file),
                 'required' => !!process['required'] }
end

def running?(process)
  File.exist?(process['pid_file'])
end

def wait_until(process, state)
  return if process['pid_file'].nil?

  polling_interval = 0.2

  if state == :running
    while !running?(process)
      sleep polling_interval
    end
  elsif state == :stopped
    while running?(process)
      sleep polling_interval
    end
  end
end

pid_checker = lambda do
  entries = []

  running = use_color ? "\e[32mon\e[0m" : 'on'
  off = use_color ? "\e[31moff\e[0m" : 'off'

  processes.each do |process|
    if process['pid_file']
      name = process['name'] || File.basename(process['pid_file']).sub('.pid', '')
      status = running?(process) ? running : off
      entries << [name, status]
    end
  end

  entries
end

project_title = use_color ? "\e[32m#{project_name.capitalize}\e[0m" : project_name.capitalize
skipped = use_color ? "\e[31m   - skipped\e[0m" : '   - skipped'
projects_regex = /^(?:#{processes.map{|p| p['name'] && Regexp.escape(p['name'])}.compact.join('|')})$/
debug_mode = !!ARGV.delete('--debug')
wait_mode = !!ARGV.delete('--wait')

find_process = lambda do |proc_name|
  processes.find{ |p| p['name'] == proc_name }
end

run_command = lambda do |command|
  cmd = command.dup

  if debug_mode
    puts `#{cmd}`
  else
    cmd << '  > /dev/null 2>&1'
    system cmd
  end
end

start_process = lambda do |process|
  if process['start'] && (process['pid_file'].nil? || !running?(process))
    if process['name']
      puts "-> Starting #{process['name']}"
    end

    run_command.call(process['start'])
    wait_until(process, :running) if wait_mode

  elsif process['pid_file'] && running?(process)
    if process['name']
      puts "-> Starting #{process['name']}"
    end

    puts skipped
  end
end

stop_process = lambda do |process|
  if process['stop'] && (process['pid_file'].nil? || running?(process))
    if process['name']
      puts "-> Stopping #{process['name']}"
    end

    run_command.call(process['stop'])
    wait_until(process, :stopped) if wait_mode

  elsif process['pid_file'] && !running?(process)
    if process['name']
      puts "-> Stopping #{process['name']}"
    end

    puts skipped
  end
end

restart_process = lambda do |process|
  grace = 10 # seconds
  stop_process.call(process)

  grace.times do |second|
    sleep 1
    break unless running?(process)
  end

  start_process.call(process)
end

def decorate(title)
  puts "\n#{title}\n"
  yield
  puts "\n"
end

def argv(num)
  ARGV[num].to_s.strip
end

case argv(0)

when ''
  decorate(project_title) do
    processes.each{ |p| start_process.call(p) }
  end

when 'minimal'
  decorate("#{project_title} (minimal)") do
    processes.select{ |p| p['required'] }.each{|p| start_process.call(p) }
  end

when 'restart'
  decorate(project_title) do
    if argv(1) =~ projects_regex
      p = find_process.call(argv(1))
      restart_process.call(p)
    else
      next
    end
  end

when projects_regex
  decorate(project_title) do
    p = find_process.call(argv(0))
    start_process.call(p)
  end

when /^(?:done|off|down|stop|enough|quit|not)$/i
  decorate(project_title) do
    if argv(1) =~ projects_regex
      p = find_process.call(argv(1))
      stop_process.call(p)
    elsif argv(1).empty?
      processes.reverse.each{ |p| stop_process.call(p) }
    else
      next
    end
  end

when /^(?:status|st)$/i
  entries = pid_checker.call
  width = entries.map(&:first).max.to_s.size + 6

  entries = entries.map do |entry|
    "#{entry.first}".ljust(width) + entry.last
  end

  statuses = entries.empty? ? 'no pids defined' : entries.join("\n  ")
  decorate(project_title) { puts "  #{statuses}" }

else
  puts 'Error: command not recognized.'
end
